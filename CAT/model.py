import torch
from torch_geometric.nn import GCNConv
from torch.nn import Dropout, ReLU, Linear, Softmax
from torch_geometric.nn import global_max_pool
import numpy as np


class CAT(torch.nn.Module):
    def __init__(self, h_size, drop_out_rate, max_method, gcn_layers):
        super(CAT, self).__init__()
        self.gcn_layers = gcn_layers
        self.h_size = h_size
       # self.max_context = max_context
        self.drop_out_rate = drop_out_rate
        self.max_method = max_method
        self.GCN_1 = GCNConv(self.h_size, self.h_size)
        self.GCN_2 = GCNConv(self.h_size, self.h_size)
        self.GCN_3 = GCNConv(self.h_size, self.h_size)
        self.GCN_4 = GCNConv(self.h_size, self.h_size)
        self.GCN_5 = GCNConv(self.h_size, self.h_size)
        self.GCN_6 = GCNConv(self.h_size, self.h_size)
        self.GCN_7 = GCNConv(self.h_size, self.h_size)
        self.GCN_8 = GCNConv(self.h_size, self.h_size)
        self.dropout = Dropout(self.drop_out_rate)
        self.relu = ReLU(inplace=True)
        self.resize_1 = Linear(self.h_size, 3)
        self.resize_2 = Linear(self.h_size, 3)
        self.resize_3 = Linear(self.h_size, 3)
        self.resize_4 = Linear(self.h_size, 3)
        self.resize_5 = Linear(self.h_size, 3)
        self.resize_6 = Linear(self.h_size, 2)
        self.resize_7 = Linear(self.h_size, 2)
        self.resize_8 = Linear(self.h_size, 2)
        self.resize_m = Linear(self.max_method*self.h_size, self.h_size)
        self.softmax = Softmax(dim=1)

    def forward(self, input_data):
        vec_1 = []
        vec_2 = []
        vec_3 = []
        vec_4 = []
        vec_5 = []
        vec_6 = []
        vec_7 = []
        vec_8 = []
        for data in input_data:
            node_features = data.x
            vul_ass_types = data.y
            edge_info = data.edge_index

            for i in range(self.gcn_layers - 1):
                feature_vec1 = self.GCN_1(node_features, edge_info)
                feature_vec1 = self.relu(feature_vec1)
                feature_vec1 = self.dropout(feature_vec1)
            feature_vec1 = self.GCN_1(feature_vec1, edge_info)
            vec_1.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec2 = self.GCN_2(node_features, edge_info)
                feature_vec2 = self.relu(feature_vec2)
                feature_vec2 = self.dropout(feature_vec2)
            feature_vec2 = self.GCN_2(feature_vec2, edge_info)
            vec_2.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec3 = self.GCN_3(node_features, edge_info)
                feature_vec3 = self.relu(feature_vec3)
                feature_vec3 = self.dropout(feature_vec3)
            feature_vec3 = self.GCN_3(feature_vec3, edge_info)
            vec_3.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec4 = self.GCN_4(node_features, edge_info)
                feature_vec4 = self.relu(feature_vec4)
                feature_vec4 = self.dropout(feature_vec4)
            feature_vec4 = self.GCN_4(feature_vec4, edge_info)
            vec_4.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec5 = self.GCN_5(node_features, edge_info)
                feature_vec5 = self.relu(feature_vec5)
                feature_vec5 = self.dropout(feature_vec5)
            feature_vec5 = self.GCN_5(feature_vec5, edge_info)
            vec_5.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec6 = self.GCN_6(node_features, edge_info)
                feature_vec6 = self.relu(feature_vec6)
                feature_vec6 = self.dropout(feature_vec6)
            feature_vec6 = self.GCN_6(feature_vec6, edge_info)
            vec_6.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec7 = self.GCN_7(node_features, edge_info)
                feature_vec7 = self.relu(feature_vec7)
                feature_vec7 = self.dropout(feature_vec7)
            feature_vec7 = self.GCN_7(feature_vec7, edge_info)
            vec_7.append(feature_vec1)

            for i in range(self.gcn_layers - 1):
                feature_vec8 = self.GCN_8(node_features, edge_info)
                feature_vec8 = self.relu(feature_vec8)
                feature_vec8 = self.dropout(feature_vec8)
            feature_vec8 = self.GCN_8(feature_vec8, edge_info)
            vec_8.append(feature_vec1)

        vec_1 = torch.cat(vec_1)
        vec_1 = self.resize_1(vec_1)
        pooled = global_max_pool(vec_1, torch.tensor(np.zeros(shape=(vec_1.shape[0])), dtype=torch.int64))
        vec_1 = self.softmax(pooled)

        vec_2 = torch.cat(vec_2)
        vec_2 = self.resize_2(vec_2)
        pooled = global_max_pool(vec_2, torch.tensor(np.zeros(shape=(vec_2.shape[0])), dtype=torch.int64))
        vec_2 = self.softmax(pooled)

        vec_3 = torch.cat(vec_3)
        vec_3 = self.resize_3(vec_3)
        pooled = global_max_pool(vec_3, torch.tensor(np.zeros(shape=(vec_3.shape[0])), dtype=torch.int64))
        vec_3 = self.softmax(pooled)

        vec_4 = torch.cat(vec_4)
        vec_4 = self.resize_4(vec_4)
        pooled = global_max_pool(vec_4, torch.tensor(np.zeros(shape=(vec_4.shape[0])), dtype=torch.int64))
        vec_4 = self.softmax(pooled)

        vec_5 = torch.cat(vec_5)
        vec_5 = self.resize_5(vec_5)
        pooled = global_max_pool(vec_5, torch.tensor(np.zeros(shape=(vec_5.shape[0])), dtype=torch.int64))
        vec_5 = self.softmax(pooled)

        vec_6 = torch.cat(vec_6)
        vec_6 = self.resize_6(vec_6)
        pooled = global_max_pool(vec_6, torch.tensor(np.zeros(shape=(vec_6.shape[0])), dtype=torch.int64))
        vec_6 = self.softmax(pooled)

        vec_7 = torch.cat(vec_7)
        vec_7 = self.resize_7(vec_7)
        pooled = global_max_pool(vec_7, torch.tensor(np.zeros(shape=(vec_7.shape[0])), dtype=torch.int64))
        vec_7 = self.softmax(pooled)

        vec_8 = torch.cat(vec_8)
        vec_8 = self.relu(vec_8)
        vec_8 = self.resize_8(vec_8)
        pooled = global_max_pool(vec_8, torch.tensor(np.zeros(shape=(vec_8.shape[0])), dtype=torch.int64))
        vec_8 = self.softmax(pooled)

        return [vec_1, vec_2, vec_3, vec_4, vec_5, vec_6, vec_7, vec_8]
